# 排序方法

## 冒泡排序

- 两重for循环，外层循环控制循环次数，内层循环控制每次循环的比较次数，复杂度为O(n^2)
- 从第一个元素开始，比较相邻的两个元素，如果第一个比第二个大，就交换他们两个。引入一个中间值，用于交换两个元素的值。或者使用异或运算交换两个元素的值。
  - es6中的 [a, b] = [b, a] 可以交换两个元素的值
- 对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对，这样最后的元素应该会是最大的数。
- 相邻元素比较完毕后，再进行下一次循环，每次循环都会将最大的数放到最后。
- 冒泡排序是一个稳定的排序算法，因为相同元素不会交换位置。
  - 稳定性：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。
- 如何优化
  - 如果某次循环没有发生交换，说明已经排好序了，可以直接退出循环。
  - 每次循环都将最大的数放到最后，下一次循环可以不用比较最后一个数。
  - 每次循环都将最小的数放到最前，下一次循环可以不用比较第一个数。
  - 以上两种优化方法可以同时使用，但是不能同时使用第三种优化方法，因为第三种优化方法会改变相同元素的相对位置，破坏稳定性。
  - 时间复杂度
    - O(n^2) 平均复杂度 , 最坏时间复杂度
    - 最好情况：O(n)，已经排好序 最好时间复杂度

- 左半部分比较好排序
- 右半部分比较好排序

3 4 2 1 5 6 7 8
