#  HTTP(超文本传输协议) /0.9
- 基于TCP的连接协议
- 只有请求行 比如 `GET /index.html`
- 以ASCII字符流的方式来进行传输

# HTTP /1.0
- 0.9的缺点：只支持HTML一种类型的资源传输
- js,css,图片,音频,视频等各种类型的资源无法传输

- 增加了请求头和响应头
  - 请求头：
    - accept：text/html
    - accept-encoding：gzip,deflate br；
    - accept-language：zh-CN,zh;q=0.9
  - 响应头：
    - content-type：text/html
    - content-length：1024
    - content-encoding：gzip
    - content-language：zh-CN

- 为了传输不同的类型资源而诞生的



# HTTP /1.1
- 1.0的缺点：每次请求都需要建立一个TCP连接，请求完毕后就断开连接
- 1.1的优点：支持长连接，一个TCP连接可以发送多个请求, 也就是持久连接，减轻了服务器的压力

- 同时最多维护6个长连接

- 队头阻塞问题：一个请求占用了连接，其他请求就会等待，这就是队头阻塞问题
  - 前一个http请求没有得到响应，后一个http请求无法发送

- HOST

- 响应头：
  - 1.0中Content-length: 1024

- 后端动态内容生成，无法确定数据大小
  - 于是采用了 Chunked Transfer 机制：将资源文件处理成若干个数据块，
  并标记数据块的大小，最后发送一个标记为 0 的数据块来告诉客户端资源传输完成


# HTTP /2.0
- 1.1的缺点：
  - 队头阻塞问题
  - 带宽利用率低
    - 同时开启多条持久连接，相互之间会竞争带宽
    - TCP的慢启动机制，会导致带宽利用率低，拖延了页面首次渲染的时间
    - 队头阻塞：前一个http请求被阻塞5s，后一个http请求又不能发送，那么该5s内，带宽就被浪费了

- 2.0的优点：
  - 一次只能维持一个TCP长连接
  - 解决队头阻塞问题
    - 多路复用：将每一个请求处理成一帧一帧的请求片段（二进制分帧层），并给每一帧打上标记，服务端接收到所有的帧之后，会将标记相同的帧合并为一个完整的请求，再响应该请求，响应体同样要处理成一帧一帧的响应片段，再发送给客户端


# HTTPS
HTTP + TLS

对称加密：
  双方都要拥有相同的秘钥，秘钥用于数据的加密和解密，如何让双方具有相同的秘钥是一个问题，使用网络传输，一旦在传输秘钥的过程中被截获，接下来的加密就没有意义了

非对称加密：
  首先服务端创建公钥和私钥，并将公钥发送出去，那么客户端也就知道了公钥，客户端创建一个秘钥，通过公钥加密将秘钥传给服务端，服务端通过独有的私钥进行解密得到正确的秘钥

# HTTP /3.0
- 2.0的缺点：
  1. TCP的队头阻塞问题：当存在数据包丢失时，TCP会重传一个新的数据包，在新包传递前，后续的数据包都会被阻塞暂停传输
  2. TCP有三次握手也是有时间的开销的

- TCP协议僵化

- 改UDP -> QUIC协议
  1. 在UDP上实现了TCP的拥塞控制，可靠性传输
  2. 集成了TLS，加密传输
  3. 实现了多路复用，解决了队头阻塞问题
  4. 实现了快速握手