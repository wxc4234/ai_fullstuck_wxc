# 1.说说你对vue的理解

# 2.说说你对SPA的理解

# 3.说说你对双向绑定的理解
- 是什么
  - 模版层的数据发生变更会导致视图层的更新，视图层的变更也会导致模版层的数据更新
- 原理 ：也就是 ViewModel 的原理
  - 监听器：对所有的数据进行监听
  - 解析器：对每个元素节点的指令进行解析

- 双向绑定的理解
  - vue的数据源会被劫持，在劫持的过程中为属性做依赖收集。vue中的观察者Watcher负责更新视图，依赖收集到的是观察者Watcher的实例对象。
  当属性值发生变更时，会触发依赖，进而会触发视图更新函数。
  - 在数据劫持的同时，vue会编译模版，解析指令，当视图层的数据发生变更时，编译器中绑定的函数会被触发，
  进而获取到最新的数据值，再次通知Watcher去触发依赖，进而更新视图。

![alt text](image.png)

# 4.生命周期

# 5.组件之间的通信
  1. 父子组件通信：父组件通过props向子组件传递数据，子组件通过defineProps接收数据
  2. 子父组件通信：子组件通过emit触发事件，父组件通过v-on(@) 监听事件；或者通过provide/inject
  3. 子父组件通信：子组件拿到父组件的数据并修改后emit出来，父组件通过v-model实现双向绑定
  4. 子父组件通信：子组件defineExpose暴露方法，父组件通过ref读取整个子组件对象来获取值
  5. 父子组件通信：父组件provide，子组件inject
  6. EventBus 事件总线 vue3中不推荐使用，但是可以通过 mitt 插件实现
  7. vuex || pinia


# 6. v-for 和 v-if 共存的问题
1. vue2中，v-for优先级更高，所以会报警告，因为性能浪费
2. vue3中，v-for和v-if共存时，v-if优先级更高，v-if没有用到for中的变量是不会报错的

# 7. data为什么要是一个函数，而不是一个对象


# 8. 什么是虚拟DOM
  1. 一个用js对象表示的DOM结构
  2. 当一次操作导致多次DOM需要修改，不使用虚拟DOM，浏览器需要重新一个一个构建这个DOM树，导致多次渲染
  3. 但是少量DOM更新diff算法同样存在性能开销
  4. 优点是：跨平台开发

# 9. 什么是diff算法
  - 同层比较，不会跨层比较
  - 深度优先，不管同层怎么样，只要有子节点就会一直比较下去
  pathVnode的步骤：
   1. 判断节点是不是文本节点，如果是文本节点，直接替换文本内容
   2. 判断节点类型是否相同，如果不相同则直接替换
   3. 相同则比较子节点，不断生成补丁包

- 双端队列
  - 提升比较的效率

# 10. vue中的修饰符


# 11. vue2和vue3的区别
1. 速度更快：虚拟DOM实现的函数被重写，效率提升，编译模版的优化
2. 体积减少：对tree-shaking更友好、更彻底
3. 更易维护：函数式编程，更好的ts的支持
4. 更接近原生语法：
5. vue3中template模版支持多个根节点，vue2中只支持一个根节点