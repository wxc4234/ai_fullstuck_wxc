- 计算属性computed
	- 让JavaScript的逻辑放到js中，避免放到template中，避免过于臃肿的模板
	- 其中内置了缓存功能，如果依赖数据没有发生更新，多次使用计算属性就会直接返回缓存结果

- v-model
	- v-model双向绑定值不仅仅是一个变量，其实是一个包含get、set属性值为函数的对象
	- 他不仅可以绑定一个属性变量，还可以绑定computed，并且可以通过：get()获取值，set()修改值，其中computed默认只有getter，如果要去修改它就需要借助setter

- Object.defineProperty()
	- 它不是一种代理方式，而是一种拦截手段
	- 它对于删除和添加数据无法监听，要想实现效果，就需要借助: $set和$delete API
	- 因为它无法对不存在的属性进行拦截，所以Vue2中的所有数据就必须要放在data中声明




# 手写题
- 防抖节流
  - 防抖：就是在设置的一段时间内，如果用户多次触发事件，事件不会被触发，只有当用户停止操作一段时间后，事件才会被触发
    - 实现的方法就是设置一个 timer ，使用clearTimeout函数，当用户重复触发事件时，这个函数就会将原来的timer清楚，重新设置一个新的timer
    - 在定时器中使用apply的原因是，我们不知道用户传入的函数是什么，所以使用apply可以将函数的this指向正确的对象，同时还可以传入参数
  - 节流：就是在设置的一段时间内，无论用户触发多少次事件，只有在第一次设置的timer结束后才会执行事件，期间用户的操作就不会去执行。
    - 实现的方法可以使用时间戳，将timer = Date.now()获取第一次的时间戳，然后在函数内部设置一个newTimer = Date.now()，然后通过newTimer - Timer > time来判断是否执行函数,如果执行函数，就将timer = newTimer

- 发布订阅模式
  - 发布订阅模式就是一种一对多的关系，当一个对象的状态发生改变时，所有依赖它的对象也会发生改变
    - 首先我们可以有多个订阅对象，因此我们需要一个数组来存储这个对象，而且我们可能有多个事件，因此我们就可以用对象来储存这个数组，这个对象的key就是他的事件名。
    - 要实现发布订阅，我们需要使用一个 on 方法来订阅事件，然后使用emit方法来发布事件，当创建on方法时，我们需要将事件名和要执行的函数存储到对象中，然后我们可以使用emit方法发布事件，我们可以将事件名作为参数传入，然后通过对象的key来指向这个事件；我们也可以通过off方法来取消订阅，同样的我们可以将事件名和要执行的函数传入，然后通过indexOf来找到要取消的函数，然后使用splice来删除这个函数

- 单例模式
  - 单例模式是指一个类只能被实例化一次，如果这个类被同时实例化多次，都是会返回同一个实例对象
    - 实现方法：我们需要构造一个静态方法来判断这个类已经被实例化了，我这用的是 `isSingle` 方法，在其中我定义了一个this.instance来存储这个实例，当没有实例化过这个类时，就把这个实例化的对象存储到this.instance中，如果已经实例化过，那我只需要返回this.instance就行了

- 深浅拷贝
  - 浅拷贝是指只拷贝一层对象，对于原始类型浅拷贝是直接拷贝值，但是对于引用类型，浅拷贝会拷贝引用类型的地址，这样就导致了原对象和拷贝的对象中引用类型的引用地址指向是同一个。当改变原类型的时候，拷贝的对象也会发生改变。
    - 实现的方法有
      - 直接赋值，通过对象身上的 `hasOwnProperty` 方法来判断原对象是否有这个属性，然后直接将原对象的值赋给新对象
      - Object.assign()，这个方法是可以传入两个参数，第一个可以传入空对象，第二个参入源对象，这样就可以将原对象的属性赋给新对象了，因为Object.assign() 方法可以用于将一个或多个源对象的可枚举属性复制到目标对象，并返回目标对象。
      - 通过解构运算符也就是拓展运算符，这个方法是用来将数组解构出来的，也可以解构对象，然后将结构出来的值赋给新对象，就可以实现浅拷贝了
      - 通过 `slice()` 方法，我们可以创建一个新的数组，然后在此方法中不加入值，以此切割整个数组，这样就可以实现浅拷贝了
      - 通过 `concat()` 方法，我们可以将一个数组连接到一个空数组上，这样就可以实现浅拷贝了

  - 深拷贝是指可以一层一层的拷贝原对象，可以拷贝源对象的所有属性，因此它拷贝时与浅拷贝不同的是，它对于引用类型不会拷贝它们的引用地址，而是会创建一个新的引用地址，将原对象的引用地址的值赋给新对象，这样就不会影响原对象了。
    - 实现的方法有
      - 递归实现：通过instanceof判断改元素是否是数组类型，如果是数组类型则可以通过for循环遍历数组，将原数组的值赋给新的数组，如果不是数组类型，则再用typeof来判断是否是引用类型，如果是的话就进行递归处理，直到改元素的值不是对象类型为止，然后将值赋给新对象
      - 通过JSON.parse(JOSN.stringify(obj))实现：这个方法是将对象转换为字符串，再将字符串转换为对象，以此来实现深拷贝。但是这种方法有着缺点，它无法拷贝函数、正则、undefined、symbol等类型，因为这些类型在转换为字符串时会丢失，所以这种方法只适合拷贝普通对象，而不适合拷贝复杂对象
      - 通过MessageChannel实现，因为MessageChannel是一个消息通道，可以用来传递消息，我们可以将原对象传递给MessageChannel，然后再将这个对象传递给新对象，这样就可以实现深拷贝了，但是这种方法只适合浏览器端，不适合node端，因为node端没有MessageChannel这个API
      - 通过sturcturedClone实现，这个方法是可以将对象进行序列化，然后再进行反序列化，这样就可以实现深拷贝了，但是这种方法只适合浏览器端，不适合node端，因为node端没有这个API。

- Promise
  - Promise是JavaScript中用来处理异步操作的一种方式，它有三种状态：初始是 `pending` 、异步操作处理成功就会把状态更改为 `fulfilled` 、如果处理失败就会将状态更改为 `rejected` 它有两个参数，一个是resolve，一个是reject，resolve是用来处理成功的回调函数，在resolve后就会将状态进行更改，reject是用来处理失败的回调函数，reject后状态就会更改。
  - 它有：then方法用来处理成功后的回调，它可以获取resolve传入的值，并且可以链式调用，因为then返回的也是一个Promise对象，catch用来处理失败后的回调，它可以获取reject传入的值，其实在then中也是可以处理失败的回调的，因为then它也接收失败后的回调，而之所以使用cacth，是因为如果都使用then的话这就会导致他的链式调用过长，并且可以避免忘记在then中传入失败的回调，而catch则可以获取所有的失败后的错误，并且统一处理错误，这样就有了更好的维护性和可读性。
  - 它还有finally方法，无论状态变更为`fulfilled`还是`rejected`它都会执行。
  - 还有all方法，它可以接收一个数组作为参数，数组中的值都是Promise对象，当所有的promise对象的状态都更改为`fulfilled`时，他就会返回一个新的promise对象，并且状态更改为`fulfilled`，并返回一个数组，值就是原来数组里面的值，如果有一个promise对象的状态更改为`rejected`，它么它返回的promise对象的状态就是`rejected`，并且返回第一个`rejected`状态的promise的值
  - 还有allSettle方法，它也接收一个数组作为参数，当所有的对象的值更改为`fulfilled`或者`rejected`时，它就会返回的promise的状态就是`fulfilled`，并且返回的数组里面的值是一个对象，它有两个属性，一个是 status，一个是 value，status用来表示这个promise的状态，一个用来表示值
  - 还有race方法，当数组内容任意一个对象的状态改变时，它会返回这个对象的状态和值。
  - 还有any方法，当数组中任意一个状态改变为fulfilled时他就会返回这个对象的状态和值，如果都是rejected那就会抛出一个错误

- call、apply、bind
  - apply 和 call 方法比较相似，它们都接收两个参数，第一个参数是要绑定的对象，apply接收的第二个参数是数组，call则是一个一个的传入，它们的执行都是会立即执行的，而bind则是返回一个函数，这个函数也是可以传入参数的，因为bind返回的函数不会立即执行，只有在函数被调用的时候才会执行

- new的实现原理
  - new的实现原理就是先创建一个新的对象，然后将这个对象的原型指向构造函数的原型，然后将构造函数的this指向这个新的对象，然后返回这个新的对象

- instanceof及typeof
  - instanceof是用来判断一个对象是否是某个构造函数身上的实例，它的原理是通过原型链来判断的，因此它只能用来判断引用类型，不能判断原始类型
  - typeof是通常用来判断原始类型的，但是他可以判断这个值是否是引用类型，但是不能判断具体是哪种引用类型，因为它对于引用类型的返回值都是Object，但是对于函数类型是function，有一个特殊的 null 他会判断为object，这是一个历史遗留的问题

- 如何实现一个虚拟列表
  - 确定可视区域大小：
    - 首先，需要确定列表容器的高度（或宽度，如果是横向滚动列表），以及每个列表项的高度。通过这两个参数可以计算出列表容器可视区域的大小。
  - 计算可见区域的起始索引和结束索引：
    - 根据列表容器的滚动位置，以及列表项的高度，可以计算出当前可见区域的起始索引和结束索引。起始索引和结束索引决定了需要渲染的数据范围。
  - 渲染可见区域的数据：
    - 根据计算得到的起始索引和结束索引，从数据源中提取出对应的数据子集。将这些数据子集渲染到列表容器中，通常是通过动态生成 DOM 元素并插入到容器中。
  - 处理滚动事件：
    - 监听列表容器的滚动事件，当用户滚动列表时，根据滚动位置更新可见区域的起始索引和结束索引。当起始索引和结束索引发生变化时，重新渲染可见区域的数据。