# 面试表达


- 后端
  - 基于KOA api 为前端应用提供API服务
    - MVC + router + SQL + JSON
  - 后端如何实现JWT
    - JWT是一种无状态的认证方式，通过在服务端生成一个token，然后通过这个token来进行认证，而不需要在服务端保存任何信息
    - 首先，用户登录时，服务端会生成一个token，然后将这个token返回给客户端，客户端在后续的请求中都会携带这个token
    - 然后，服务端在接收到这个token时，会通过解析这个token来获取用户的信息，然后通过这个信息来判断用户是否有权限访问这个资源
    - 最后，服务端会通过这个信息来判断用户是否有权限访问这个资源，如果有权限就返回资源，如果没有权限就返回401状态码

  - MVC 经典设计模式分层
    -  /posts/1 Get 这是一种restful API 的设计方式，通过不同的请求方式来获取不同的资源
       -  get和post的区别
          -  get请求是通过url来传递参数的，而post请求是通过请求体来传递参数的，因此get请求时不安全的
          -  get请求是有长度限制的，因为url的长度是有限制的，而post请求是没有限制的
          - get请求是放在请求行里面的，而post请求是放在请求体里面的
          - get请求是可以被缓存的，而post请求是不可以被缓存的
          - get是在资源更新时都会请求一次，而post不会每次都请求
    - 用户从url路由进来，参数校验/业务逻辑交给controller（控制器），controller 实例化相应数据表模型，完成数据操作（增删改查）这是在model层完成的，最后将Model层返回的数据以JSON格式响应给用户（套view层）
    - MVC指的是：Model（模型层）数据库的映射，View（视图层）其中就是一些html模版，Controller（控制器层）负责校验和一些业务逻辑
    - View层不可以直接操作Model层，只能通过Controller层来操作Model层
- 中间件 middleware 用的就是一种洋葱模型，它是node的应用运行的一种方式，通过中间件来处理请求，然后再返回给客户端
- 中间件的本质就是一个函数，它接收三个参数，分别是ctx、next、error，ctx是上下文对象，next是下一个中间件，error是错误对象
  - 有CORS中间件，用来解决跨域问题
  - jsonParser，可以用来解析post请求的请求体
  - 鉴权中间件，可以用来判断用户是否有权限访问这个资源
  - 路由中间件，可以用来处理不同的请求
  - 错误处理中间件，可以用来处理错误

- 以post 功能模块举例
  - 用户从/posts GET进来想要获得文章列表，我们可以安排sort中间件，将文章按照时间排序，然后将文章列表返回给用户
  - 使用filter中间件负责筛选文章，
  - 使用pagination中间件负责分页
  - 最后再交给控制器函数去处理，将中间件的思想执行到底
  - post.service.ts文件内，进行数据库操作，将数据返回给控制器
  - 中间件的思想就是将一个复杂的任务拆分成多个小任务，然后再将这些小任务组合起来，最后再交给控制器函数去处理

- 每个后端项目的中间件一定会是错误处理中间件，用来处理错误，比如404错误，500错误等


- JWT
  - 是如何将用户信息加密到token中的

- 如何实现大文件的上传的
  - 通过分片上传，将文件分成多个小文件，然后再上传到服务器，最后再合并成一个文件
  - 通过流的方式上传，通过流的方式上传文件，可以减少内存的占用

- vue2与vue3的区别
- vue2中Object.defineProperty对于数组的处理是如何解决的
- react与vue的区别
- react中的hooks api 有哪些
- 动态路由菜单怎么实现，如果前端普通用户直接输入URL跳转，怎么实现这个判断
怎么跟后端一起实现动态权限
  - 动态路由菜单可以通过 vue 中的 vue-router 来实现，通过后端返回的数据来动态生成路由，然后通过 router.addRoutes() 来动态添加路由
  - 判断用户是否有权限访问这个页面，可以通过路由守卫来实现，通过 router.beforeEach() 来判断用户是否有权限访问这个页面
- 如何判断一个对象为空
  - 通过Object.keys()来判断，就是通过判断对象的key是否为空来判断对象是否为空
  - 通过Onject.values()来判断，就是通过判断对象的值是否为空来判断对象是否为空
  - 可以通过遍历对象的key来判断
- 虚拟列表的实现原理
  - 首先就是要去计算出列表的高度
  - 然后通过滚动事件来计算出当前滚动的位置
  - 然后通过当前滚动的位置来计算出当前显示的数据
  - 然后通过当前显示的数据来渲染列表

- 暂时性死区
  - 在es6中，let和const声明的变量不会产生声明提升，因此在声明之前调用这个变量就会报错，这就是暂时性死区；

- cache-control的no-store和no-cache在第二次请求时有什么区别
  - no-store：意味着缓存服务器不能缓存任何形式的数据，每次请求都要重新获取资源数据，在第二次请求时，不管客户端发送什么请求，缓存服务器都不会返回任何已经存储的响应，而是发送到原服务器获取新的响应
  - no-cache：意味着允许缓存服务器缓存数据，但是会去检测数据的有效性，如果有效就返回缓存数据，如果无效了，就会向原服务器发送请求，它依靠If-Modified-Since 或 If-None-Match 来完成。在第二次请求时，缓存服务器会向原服务器发送请求，如果原服务器没有响应，会返回304状态码，缓存服务器可以使用缓存的数据

- 常见的DOM操作
  - createElement：可以创建一个元素
  - getElementById: 可以通过id来获取元素
  - getquerySelector：可以通过css选择器来获取元素
  - getElementsByClassName：可以通过类名来获取元素
  - gtElementsByTagName：可以通过标签名来获取元素
  - appendChild：可以向元素中天街子元素
  - removeChild：可以删除元素中的子元素
  - replaceChild：可以替换元素中的子元素
  - innerHtml：可以设置元素的内容
  - textContent：可以设置元素的文本内容
  - offsetWidth：可以获取元素的宽度
  - offsetHeight：可以获取元素的高度

- token为什么放在本地缓存，而不是使用cookie
  - 首先cookie它的大小史有限制的，只有5kb左右，而localStorage和sessionStorage可以存储10m以上的数据
  - 并且cookie在每次请求时都会被发送到服务器，而这两个就不会；
  - 并且cookie是不安全的，可以通过document.cookie来获取，可以通过设置httpOnly来防止，还可以通过设置secure来防止
  - 但是放在cookie中，每次请求都会携带，而放在localStorage中，只有在前端请求时才会携带

- 为什么有了Promise还需要有async/await
  - 因为Promise它引用了链式调用，因此在处理多个异步请求的时候，容易形成冗长的链式调用，导致代码难以维护，而async可以让我们像写同步代码一样写异步代码，因此更加简洁。
  - 并且async还能通过await来实现在需要的地方暂停代码的执行，能更好的去实现条件语句和循环语句等控制结构
  - 并且async还能更好的处理错误，可以通过try catch来捕获错误，而Promise只能通过then来捕获错误，因此async更加方便

- 强缓存和协商缓存
  - 强缓存是指：浏览器在请求资源时，会先判断是否命中了强缓存，如果命中了，就会从缓存中读取数据，如果没有命中，就会请求服务器
    - 它是通过设置响应头来实现的，通过设置Cache-Control和Expires来实现的，相较于Expires，Cache-Control的优点是可以设置更多的值，比如no-store、no-cache等，而Expires只能设置一个时间，并且Expires会被本地的时间影响，而Cache-Control不会，因为它是通过时间戳来判断的
  - 协商缓存是指：当强缓存的时效过期=时，浏览器在请求资源的之前会先和服务器进行‘协商’，判断该资源是否有更新，如果没有更新就会返回304状态码，告诉浏览器可以使用本地缓存，如果有更新就会返回新的资源
    - 它是通过在请求头中设置 If-Modified-Since（Last-Modified） 和 If-None-Match（Etag） 来实现的，服务器会通过判断这两个值来判断资源是否有更新，如果没有更新就会返回304状态码，如果有更新就会返回新的资源
    - 对于Last-Modified和Etag的选择，优先使用Etag，因为Etag是通过文件的内容来生成的，而Last-Modified是通过文件的修改时间来生成的，因此Etag更加准确，但是Etag会消耗服务器的性能，因此在性能要求不高的情况下，可以使用Last-Modified


- scoped的功能
  - scoped是一个属性选择器，它的作用就是给当前的样式加上一个唯一的标识，这样就可以避免样式的冲突，因为scoped会给当前的样式加上一个唯一的标识，这样就可以避免样式的冲突，如data-v-xxxxx


- 状态码
  - 1xx：信息性状态码，表示请求已经接收，继续处理
    - 100：继续，表示服务器已经接收到请求头，并且客户端应该继续发送请求体
    - 101：切换协议，表示服务器已经理解了客户端的请求，并且将通过升级协议来完成这个请求
    - 102：处理中，表示服务器已经接收到请求，并且正在处理中
  - 2xx：成功状态码，表示请求已经成功处理
    - 200：成功，表示请求已经成功处理
    - 201：创建，表示请求已经成功处理，并且创建了一个新的资源
    - 202：接受，表示请求已经接受，但是还没有处理
    - 203：非授权信息，表示请求已经成功处理，但是返回的信息可能不是最新的
    - 204：无内容，表示请求已经成功处理，但是没有返回任何内容
    - 205：重置内容，表示请求已经成功处理，但是需要重置视图
    - 206：部分内容，表示请求已经成功处理，但是只返回了部分内容
  - 3xx：重定向状态码，表示需要进行重定向
    - 300：多种选择，表示请求的资源有多种选择
    - 301：永久重定向，表示请求的资源已经永久重定向
    - 302：临时重定向，表示请求的资源已经临时重定向
    - 303：查看其他位置，表示请求的资源已经查看其他位置
    - 304：未修改，表示请求的资源没有修改
    - 305：使用代理，表示请求的资源需要使用代理
    - 307：临时重定向，表示请求的资源已经临时重定向
    - 308：永久重定向，表示请求的资源已经永久重定向
  - 4xx：客户端错误状态码，表示客户端发送的请求有错误
    - 400：错误请求，表示客户端发送的请求有错误
    - 401：未授权，表示客户端没有权限访问这个资源
    - 402：需要付费，表示客户端需要付费才能访问这个资源
    - 403：禁止，表示客户端没有权限访问这个资源
    - 404：未找到，表示客户端请求的资源没有找到
    - 405：方法不允许，表示客户端请求的方法不允许
    - 406：不接受，表示客户端请求的资源不接受
    - 407：需要代理，表示客户端需要使用代理
    - 408：请求超时，表示客户端请求超时
    - 409：冲突，表示客户端请求的资源冲突
  - 5xx：服务器错误状态码，表示服务器处理请求时出现错误
    - 500：服务器错误，表示服务器处理请求时出现错误
    - 501：未实现，表示服务器没有实现这个请求
    - 502：错误网关，表示服务器作为网关时出现错误
    - 503：服务不可用，表示服务器当前不可用
    - 504：网关超时，表示服务器作为网关时超时
    - 505：HTTP版本不支持，表示服务器不支持这个HTTP版本
    - 506：变量也有冲突，表示服务器处理请求时发现变量冲突
    - 507：存储不足，表示服务器存储不足
    - 508：循环检测，表示服务器处理请求时发现循环检测
    - 509：带宽限制，表示服务器带宽限制
    - 510：不扩展，表示服务器不支持这个扩展
    - 511：网络认证要求，表示服务器需要网络认证