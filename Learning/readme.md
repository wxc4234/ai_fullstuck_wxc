# 面试表达


- 后端
  - 基于KOA api 为前端应用提供API服务
    - MVC + router + SQL + JSON
  - 后端如何实现JWT
    - JWT是一种无状态的认证方式，通过在服务端生成一个token，然后通过这个token来进行认证，而不需要在服务端保存任何信息
    - 首先，用户登录时，服务端会生成一个token，然后将这个token返回给客户端，客户端在后续的请求中都会携带这个token
    - 然后，服务端在接收到这个token时，会通过解析这个token来获取用户的信息，然后通过这个信息来判断用户是否有权限访问这个资源
    - 最后，服务端会通过这个信息来判断用户是否有权限访问这个资源，如果有权限就返回资源，如果没有权限就返回401状态码

  - MVC 经典设计模式分层
    -  /posts/1 Get 这是一种restful API 的设计方式，通过不同的请求方式来获取不同的资源
       -  get和post的区别
          -  get请求是通过url来传递参数的，而post请求是通过请求体来传递参数的，因此get请求时不安全的
          -  get请求是有长度限制的，因为url的长度是有限制的，而post请求是没有限制的
          - get请求是放在请求行里面的，而post请求是放在请求体里面的
          - get请求是可以被缓存的，而post请求是不可以被缓存的
          - get是在资源更新时都会请求一次，而post不会每次都请求
    - 用户从url路由进来，参数校验/业务逻辑交给controller（控制器），controller 实例化相应数据表模型，完成数据操作（增删改查）这是在model层完成的，最后将Model层返回的数据以JSON格式响应给用户（套view层）
    - MVC指的是：Model（模型层）数据库的映射，View（视图层）其中就是一些html模版，Controller（控制器层）负责校验和一些业务逻辑
    - View层不可以直接操作Model层，只能通过Controller层来操作Model层
- 中间件 middleware 用的就是一种洋葱模型，它是node的应用运行的一种方式，通过中间件来处理请求，然后再返回给客户端
- 中间件的本质就是一个函数，它接收三个参数，分别是ctx、next、error，ctx是上下文对象，next是下一个中间件，error是错误对象
  - 有CORS中间件，用来解决跨域问题
  - jsonParser，可以用来解析post请求的请求体
  - 鉴权中间件，可以用来判断用户是否有权限访问这个资源
  - 路由中间件，可以用来处理不同的请求
  - 错误处理中间件，可以用来处理错误

- 以post 功能模块举例
  - 用户从/posts GET进来想要获得文章列表，我们可以安排sort中间件，将文章按照时间排序，然后将文章列表返回给用户
  - 使用filter中间件负责筛选文章，
  - 使用pagination中间件负责分页
  - 最后再交给控制器函数去处理，将中间件的思想执行到底
  - post.service.ts文件内，进行数据库操作，将数据返回给控制器
  - 中间件的思想就是将一个复杂的任务拆分成多个小任务，然后再将这些小任务组合起来，最后再交给控制器函数去处理

- 每个后端项目的中间件一定会是错误处理中间件，用来处理错误，比如404错误，500错误等


- JWT
  - 是如何将用户信息加密到token中的

- 如何实现大文件的上传的
  - 通过分片上传，将文件分成多个小文件，然后再上传到服务器，最后再合并成一个文件
  - 通过流的方式上传，通过流的方式上传文件，可以减少内存的占用

- vue2与vue3的区别
- vue2中Object.defineProperty对于数组的处理是如何解决的
- react与vue的区别
- react中的hooks api 有哪些
- 动态路由菜单怎么实现，如果前端普通用户直接输入URL跳转，怎么实现这个判断
怎么跟后端一起实现动态权限
  - 动态路由菜单可以通过 vue 中的 vue-router 来实现，通过后端返回的数据来动态生成路由，然后通过 router.addRoutes() 来动态添加路由
  - 判断用户是否有权限访问这个页面，可以通过路由守卫来实现，通过 router.beforeEach() 来判断用户是否有权限访问这个页面
- 如何判断一个对象为空
  - 通过Object.keys()来判断，就是通过判断对象的key是否为空来判断对象是否为空
  - 通过Onject.values()来判断，就是通过判断对象的值是否为空来判断对象是否为空
  - 可以通过遍历对象的key来判断
- 虚拟列表的实现原理
  - 首先就是要去计算出列表的高度
  - 然后通过滚动事件来计算出当前滚动的位置
  - 然后通过当前滚动的位置来计算出当前显示的数据
  - 然后通过当前显示的数据来渲染列表

- 暂时性死区
  - 在es6中，let和const声明的变量不会产生声明提升，因此在声明之前调用这个变量就会报错，这就是暂时性死区；

- cache-control的no-store和no-cache在第二次请求时有什么区别
  - no-store：意味着缓存服务器不能缓存任何形式的数据，每次请求都要重新获取资源数据，在第二次请求时，不管客户端发送什么请求，缓存服务器都不会返回任何已经存储的响应，而是发送到原服务器获取新的响应
  - no-cache：意味着允许缓存服务器缓存数据，但是会去检测数据的有效性，如果有效就返回缓存数据，如果无效了，就会向原服务器发送请求，它依靠If-Modified-Since 或 If-None-Match 来完成。在第二次请求时，缓存服务器会向原服务器发送请求，如果原服务器没有响应，会返回304状态码，缓存服务器可以使用缓存的数据

- 常见的DOM操作
  - createElement：可以创建一个元素
  - getElementById: 可以通过id来获取元素
  - getquerySelector：可以通过css选择器来获取元素
  - getElementsByClassName：可以通过类名来获取元素
  - gtElementsByTagName：可以通过标签名来获取元素
  - appendChild：可以向元素中天街子元素
  - removeChild：可以删除元素中的子元素
  - replaceChild：可以替换元素中的子元素
  - innerHtml：可以设置元素的内容
  - textContent：可以设置元素的文本内容
  - offsetWidth：可以获取元素的宽度
  - offsetHeight：可以获取元素的高度

- token为什么放在本地缓存，而不是使用cookie
  - 首先cookie它的大小史有限制的，只有5kb左右，而localStorage和sessionStorage可以存储10m以上的数据
  - 并且cookie在每次请求时都会被发送到服务器，而这两个就不会；
  - 并且cookie是不安全的，可以通过document.cookie来获取，可以通过设置httpOnly来防止，还可以通过设置secure来防止
  - 但是放在cookie中，每次请求都会携带，而放在localStorage中，只有在前端请求时才会携带

- 为什么有了Promise还需要有async/await
  - 因为Promise它引用了链式调用，因此在处理多个异步请求的时候，容易形成冗长的链式调用，导致代码难以维护，而async可以让我们像写同步代码一样写异步代码，因此更加简洁。
  - 并且async还能通过await来实现在需要的地方暂停代码的执行，能更好的去实现条件语句和循环语句等控制结构
  - 并且async还能更好的处理错误，可以通过try catch来捕获错误，而Promise只能通过then来捕获错误，因此async更加方便

- 强缓存和协商缓存
  - 强缓存是指：浏览器在请求资源时，会先判断是否命中了强缓存，如果命中了，就会从缓存中读取数据，如果没有命中，就会请求服务器
    - 它是通过设置响应头来实现的，通过设置Cache-Control和Expires来实现的，相较于Expires，Cache-Control的优点是可以设置更多的值，比如no-store、no-cache等，而Expires只能设置一个时间，并且Expires会被本地的时间影响，而Cache-Control不会，因为它是通过时间戳来判断的
  - 协商缓存是指：当强缓存的时效过期=时，浏览器在请求资源的之前会先和服务器进行‘协商’，判断该资源是否有更新，如果没有更新就会返回304状态码，告诉浏览器可以使用本地缓存，如果有更新就会返回新的资源
    - 它是通过在请求头中设置 If-Modified-Since（Last-Modified） 和 If-None-Match（Etag） 来实现的，服务器会通过判断这两个值来判断资源是否有更新，如果没有更新就会返回304状态码，如果有更新就会返回新的资源
    - 对于Last-Modified和Etag的选择，优先使用Etag，因为Etag是通过文件的内容来生成的，而Last-Modified是通过文件的修改时间来生成的，因此Etag更加准确，但是Etag会消耗服务器的性能，因此在性能要求不高的情况下，可以使用Last-Modified


- scoped的功能
  - scoped是一个属性选择器，它的作用就是给当前的样式加上一个唯一的标识，这样就可以避免样式的冲突，因为scoped会给当前的样式加上一个唯一的标识，这样就可以避免样式的冲突，如data-v-xxxxx


- 状态码
  - 1xx：信息性状态码，表示请求已经接收，继续处理
    - 100：继续，表示服务器已经接收到请求头，并且客户端应该继续发送请求体
    - 101：切换协议，表示服务器已经理解了客户端的请求，并且将通过升级协议来完成这个请求
    - 102：处理中，表示服务器已经接收到请求，并且正在处理中
  - 2xx：成功状态码，表示请求已经成功处理
    - 200：成功，表示请求已经成功处理
    - 201：创建，表示请求已经成功处理，并且创建了一个新的资源
    - 202：接受，表示请求已经接受，但是还没有处理
    - 203：非授权信息，表示请求已经成功处理，但是返回的信息可能不是最新的
    - 204：无内容，表示请求已经成功处理，但是没有返回任何内容
    - 205：重置内容，表示请求已经成功处理，但是需要重置视图
    - 206：部分内容，表示请求已经成功处理，但是只返回了部分内容
  - 3xx：重定向状态码，表示需要进行重定向
    - 300：多种选择，表示请求的资源有多种选择
    - 301：永久重定向，表示请求的资源已经永久重定向
    - 302：临时重定向，表示请求的资源已经临时重定向
    - 303：查看其他位置，表示请求的资源已经查看其他位置
    - 304：未修改，表示请求的资源没有修改
    - 305：使用代理，表示请求的资源需要使用代理
    - 307：临时重定向，表示请求的资源已经临时重定向
    - 308：永久重定向，表示请求的资源已经永久重定向
  - 4xx：客户端错误状态码，表示客户端发送的请求有错误
    - 400：错误请求，表示客户端发送的请求有错误
    - 401：未授权，表示客户端没有权限访问这个资源
    - 402：需要付费，表示客户端需要付费才能访问这个资源
    - 403：禁止，表示客户端没有权限访问这个资源
    - 404：未找到，表示客户端请求的资源没有找到
    - 405：方法不允许，表示客户端请求的方法不允许
    - 406：不接受，表示客户端请求的资源不接受
    - 407：需要代理，表示客户端需要使用代理
    - 408：请求超时，表示客户端请求超时
    - 409：冲突，表示客户端请求的资源冲突
  - 5xx：服务器错误状态码，表示服务器处理请求时出现错误
    - 500：服务器错误，表示服务器处理请求时出现错误
    - 501：未实现，表示服务器没有实现这个请求
    - 502：错误网关，表示服务器作为网关时出现错误
    - 503：服务不可用，表示服务器当前不可用
    - 504：网关超时，表示服务器作为网关时超时
    - 505：HTTP版本不支持，表示服务器不支持这个HTTP版本
    - 506：变量也有冲突，表示服务器处理请求时发现变量冲突
    - 507：存储不足，表示服务器存储不足
    - 508：循环检测，表示服务器处理请求时发现循环检测
    - 509：带宽限制，表示服务器带宽限制
    - 510：不扩展，表示服务器不支持这个扩展
    - 511：网络认证要求，表示服务器需要网络认证


# 得到
- vue的响应式原理
vue中的响应式原理是一种设计模式，它主要是通过数据层的变化来驱动视图层的变化，对于vue的响应式原理来说，他有几个核心的概念：
  - 首先就是数据劫持：在vue被实例化的时候，他会有一个observer的实例它负责遍历整个数据对象，然后通过Object.defineProperty来对数据的每一个属性进行劫持，当数据被访问时，会触发这个数据的getter方法，当数据被修改时，会触发这个数据的setter方法
  - 然后他会进行依赖收集的操作：当数据被一个属性（这个属性也就是Wattcher）访问时，会触发这个数据身上的getter方法，getter方法会将这个Wattcher添加到这个数据的依赖中也就是Dep中，这样的话当数据更新时就可以通知到所有依赖它的Wattcher了
  - 依赖收集之后就是派发更新了：当数据进行更新的时候，会触发这个数据身上的setter方法，setter方法会通知Dep，Dep再去通知所有的Watcher，Watcher收到通知之后会执行update方法，去更新视图，这样我们就实现了数据的响应式了

- vue的双向绑定原理
vue是一种MVVM的框架，它的核心就是View-Model层，vue的双向绑定就是通过ViewModel层来实现的，在ViewModel层中，会将Model层的数据绑定到View层。它的实现原理是基于响应式处理来实现的，他也会有一个数据劫持和依赖收集的过程。
双向绑定的实现主要是使用v-model指令来实现的，v-model是一个语法糖，它是v-bind、v-on和input事件的结合，数据到视图的实现原理是通过v-bind来实现的，v-bind主要是运用响应式原理，将数据绑定到视图上，视图到数据的实现是通过v-on和input的事件来实现的，通过v-on来监听input事件，然后通过input事件来更新数据

- ref 和 reactive 有什么区别（ reactive 里为什么只能放引用类型）
reactive：
  - reactive主要是用来处理复杂数据类型的，比如对象和数组，它不能直接用于代理基本数据类型，因为其内部是通过Proxy来实现代理操作的，而Proxy只能拦截对象的操作，因此reactive只能用于代理对象和数组
ref：
  - 它可以代理所有的数据类型，但是通常我们都是更倾向于使用它来代理基本数据类型
  - 它对于基本数据类型的代理是通过使用一个value对象来包装的，然后通过Proxy来代理这个对象，这样就可以实现对基本数据类型的代理了
  - 对于引用类型的代理，ref中也是通过包装一个value对象来实现的，但是它的包装主要是对reactive的一个包装，可以说他对于引用类型的代理是通过reac来实现的
  - 因此与reactive不同的是，对于ref代理的数据我们需要通过.value来访问

- vue2和vue3的区别
  - 响应式方面：
    - 在vue2中我们都是通过使用Object.defineProperty来实现响应式的，但是这个方法有缺陷，它无法监听数组的变化，虽然vue2增加了set和delete的方法来解决了一部分的问题，但是它只能监听数组下标的变化，而不能监听数组的长度的变化，因此在vue2中是通过重写数组的方法来实现的
    - 在vue3中，我们是通过Proxy来实现响应式的，Proxy它有13个拦截器，因此它可以更好的监听数据的变化，并且它还可以监听数组的变化
  - API方面：
    - vue2中我们使用的是Options API，它其中有data、methods、computed等，因为它是通过选项的方式来进行组织的，所以当组件的逻辑变得复杂的时候，就会导致逻辑分散在各个选项中，不易维护
    - vue3中使用的是Composition API，它是通过函数的方式来组织组件内的逻辑的，它让我们能进行函数式的编程，可以使代码能更好的进行复用
  - 生命周期
    - 在vue2中生命周期钩子函数有8个，分别有四个过程，创建阶段是：beforeCreate、created，挂载阶段：beforeMount、mounted，更新阶段：beforeUpdate、updated，销毁阶段：beforeDestroy、destroyed，对于特殊特还有keep-alive中的钩子函数：activated、deactivated，分别是组件被激活和组件被停用时触发
    - 在vue3中，beforeCreate、created钩子函数被setup语法糖给取代了，对于挂载阶段和更新阶段都加上了on的前缀，比如onBeforeMount、onMounted、onBeforeUpdate、onUpdated，对于销毁阶段它被改成了onbeforeUnmount、onUnmounted，对于keep-alive也被替换成了onActivated、onDeactivated
  - 根节点
    - 在vue2中我们需要再template中定义一个div来包裹所有的其他元素，因此这会造成多创造了一个div元素，影响页面的性能和结构
    - 在vue3中我们使用了Fragment来替代div，Fragment是一个空的标签，他不会在页面上显示，因此也就不会影响页面的性能和结构
  - TypeScript
    - 在vue3中他对于TypeScript的支持更加的友好，因为vue3就是使用TypeScript来进行开发的
  - 性能
    - 在vue3中还对diff算法进行了优化，比如vue2中是通过递归的方式来进行比较的，在vue3中是通过双端比较的方式来进行比较的这样可以减少比较的次数

- Proxy是什么
  - 它是ES6新增的一个对象，主要是用来拦截对象的操作，他有13种拦截器，比如get、set、deleteProperty、has、ownKeys等，通过这些拦截器可以实现对对象的操作，比如对对象的读取、设置、删除、遍历等

- vuex 和 pinia 相比 有什么区别，有什么优缺点
vuex 和 pinia 都是一种状态管理的工具
  - 在vuex中，他有一个store，store中有state、mutations、actions、getters等方法，其中state用来保存所有共享状态数据，mutations是唯一可以修改state的地方，它接收包含state参数的回调函数和一个字符串类型的事件类型，它主要是用来处理同步操作，异步操作是交给actions来处理的，actions它不能直接修改state，它只能通过commit来提交一个mutation来修改state，getters是用来获取state的，它类似于计算属性，可以根据state的值来计算出一个新的值，它不能直接修改state，它只能获取state的值
  - 它的优点是：它是一个官方的状态管理工具，有着成熟的生态，它适合于大型项目的构建
  - 缺点就是：它的使用方式比较繁琐，对于小型项目来说，可能会显得有些臃肿

  - pinia它是基于vue3的状态管理工具，它是通过store来管理状态的，和vuex不同的是，它没有mutations，它是通过actions来修改state的，在actions中可以进行同步和异步操作，它还有一个auto import的特性，可以自动导入store
  - 它的优点是：它更轻量级，更适合小型项目的构建，通过自动导入的功能，可以给开发者带来更好的体验
  - 缺点是：相较于vuex，它的生态还不够完善，可能会有一些问题，并且它只适合于vue3的项目，因为它是基于vue3的

- vuex的调用过程
  - 首先创建一个store文件，然后在main.js中use这个store，然后在组建中可以通过this.$store来访问这个store，通过this.$store.state来访问state，通过this.$store.commit来提交一个mutations，通过this.$store.dispatch来提交actions，通过this.$state.getters来获取getters

- vite 和 webpack 各自的优点（vite为什么快）
  - vite是一个脚手架工具，它是通过浏览器的ES Module来开发的，它不需要提前打包所有的代码，而是通过import的方式来按需加载模块，这样就减少了打包的时间，因此它的启动速度就更快
  - 它还有一个更好的热更新功能，当源代码发生改变时，它因为ES Module的特性，只会重新编译发生改变的模块，而不是整个项目，这样就减少了编译的时间
  - 它利用了ESBuild构建工具，因此打包速度更快
  - 它提供了更简洁的配置，能使开发者更快的上手

  - webpack它是通过loader和plugin来实现打包的，它会根据我们的配置文件中的entry，分析出所有的依赖然后打包成一个文件交给浏览器去渲染，因此它的打包速度会比较慢
  - 它的优点是：它有更丰富的生态，几乎可以处理所有的资源，因此它的稳定性更好
  - 它是根据配置文件进行打包的，因此我们可以灵活的使用配置来满足我们的需求
  - 并且webpack还提供了代码分割能力，可以通过动态导入的方式将代码分割成多个chunk，从而优化加载时间和首次渲染速度